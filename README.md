# VampireClone

# Unity 2D Action Survivor

Топ-даун 2D выживалка с системой object pooling и data-driven конфигурацией.

## Запуск

1. Клонировать репозиторий
2. Открыть в Unity Hub (2022.3+ LTS)  
3. Проверить пулы в окне ObjectPoolManager
4. Запустить MainScene

## Архитектура

Проект использует две ключевые подхода:

**Object Pooling**  
Все объекты (враги, снаряды, опыт) берутся из заранее созданного пула и возвращаются обратно. 
Пулы настраиваются в JSON файле без перекомпиляции кода.

**Data-Driven**  
Все параметры врагов, оружия и игры хранятся в JSON конфигурации. 
Изменение баланса происходит редактированием файла, без изменения кода.


Что я реализовал

Я написал управление игроком: PlayerController.cs — обработка ввода, движение и базовое взаимодействие.
Я написал слежение за камерой: CameraFollow.cs — плавное отслеживание игрока.
Я реализовал систему пуллинга объектов: ObjectPoolManager.cs, интерфейс IPooledObject .cs, PooledProjectile.cs, PoolableEnemy.cs — переиспользование префабов для производительности.
Я реализовал менеджеры игры: DataManager.cs (загрузка/хранение данных), EnemySpawnManager.cs (спавн врагов), ExperienceManager.cs, WeaponManager.cs, UIManager.cs — централизованное управление подсистемами.
Я сделал систему оружия: WeaponStats.cs, WeaponLevelManager.cs, GarlicAura.cs — параметры оружия, прокачка и особые эффекты.
Я реализовал поведение с опытом: ExperienceOrbMovement.cs, ExperienceOrbCollector.cs — орбы опыта, их движение и сбор игроком.
Я создал структуру данных: Data.cs — модели/настройки, используемые в игре.
Короткая архитектурная заметка

Код организован по подсистемам в папке Scripts (Core, Managers, Data, Weapon, Experience, Interfaces). Я старался разделять ответственность: менеджеры управляют жизненным циклом и данными, Core содержит поведение объектов, Interfaces — контракты для слабой связанности.
Основные точки взаимодействия: менеджеры инициализируют и запрашивают сервисы (например, пул, оружие, опыт), а игровые объекты реализуют поведение через MonoBehaviour и интерфейсы из Interfaces.


Object pooling: Проект использует пул объектов для повторного использования префабов и уменьшения аллокаций во время игры. Основная реализация — ObjectPoolManager.cs. Контракт пуллинга задаёт [Assets/Scripts/Interfaces/IPooledObject .cs](Assets/Scripts/Interfaces/IPooledObject .cs).

Конфигурации и игровые данные вынесены в отдельную слой/модели, что позволяет менять параметры без правки логики. Основные файлы: Data.cs и менеджер загрузки/хранения данных DataManager.cs. 
## Разработка

AI использовался как консультант по архитектуре и отладке:
- Выявление проблем с пулингом объектов
- Анализ коллизий и физики  
- Рефакторинг повторяющегося кода
- Добавление debug-логов для диагностики